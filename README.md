### **Phase 1: 기반 다지기 및 핵심 기능 구현 (Architecture & Backend)**

**목표:** 아이디어를 구체적인 설계로 옮기고, 동작하는 백엔드 API의 뼈대를 완성한다.

- **1. 데이터베이스 설계 (ERD):**
    - **키포인트:** 단순히 테이블을 나열하는 것을 넘어, **테이블 간의 관계(1:N, N:M)를 명확히 정의**하는 것이 핵심. `orders`와 `products`의 N:M 관계를 해결하기 위해 `order_items`라는 중간 테이블을 두는 **정규화** 과정이 매우 중요했다.
- **2. ORM과 엔티티 모델링 (JPA & Hibernate):**
    - **키포인트:** `@Entity`는 DB 테이블의 '설계도'이며, `@Id`, `@GeneratedValue`, `@Column` 같은 어노테이션으로 세부 규칙을 정한다. **`@ManyToOne`, `@OneToMany`*를 통해 객체 세상의 관계와 DB 세상의 외래 키(FK)를 연결했다.
    - **핵심 경험:** **`cascade` (영속성 전이)**와 **`orphanRemoval` (고아 객체 제거)** 옵션을 통해, 부모 엔티티(`Order`)만 관리해도 자식 엔티티(`OrderItem`)가 알아서 처리되는 객체지향적인 설계를 경험했다.
- **3. 리포지토리와 서비스 계층 분리:**
    - **키포인트:** **`Controller` (요청 접수) → `Service` (비즈니스 로직) → `Repository` (데이터 처리)**로 역할을 명확히 분리했다. 이를 통해 코드가 훨씬 더 깔끔해지고, 테스트와 유지보수가 용이해졌다.
    - **핵심 경험:** **더티 체킹(Dirty Checking)**의 마법. `@Transactional` 환경에서는, 조회한 엔티티의 상태만 변경하면 JPA가 알아서 `UPDATE` 쿼리를 날려준다는 것을 배웠다. `save()`는 새로운 객체를 저장할 때만 사용한다.
- **4. 인증/인가 시스템 구축 (Spring Security & JWT):**
    - **키포인트:** **인증(Authentication, 누구인가?)**과 **인가(Authorization, 무엇을 할 수 있는가?)**는 다르다. JWT를 통해 이 둘을 모두 구현했다.
    - **핵심 경험:** JWT 페이로드에 `email`뿐만 아니라 **`role`(역할)을 포함**시켜야만, 토큰 자체만으로 사용자의 권한을 판단할 수 있는 **Stateless** 시스템이 완성된다는 것을 깨달았다. `JwtAuthenticationFilter`는 이 정보를 읽어 보안 컨텍스트에 등록하는 역할을 했다.

### **Phase 2: 기능 고도화 (Elasticsearch 검색 엔진 연동)**

**목표:** RDBMS의 한계를 이해하고, 검색 전문 도구를 연동하여 서비스의 질을 높인다.

- **1. 이기종 데이터 아키텍처:**
    - **키포인트:** 주 데이터 저장소(PostgreSQL)와 검색/분석용 저장소(Elasticsearch)의 **역할을 분리**했다. 모든 것을 하나의 DB로 해결하려 하지 않는 것이 현대적인 아키텍처의 핵심이다.
- **2. 데이터 동기화:**
    - **키포인트:** **원본 데이터(Source of Truth)는 항상 RDBMS(PostgreSQL)**에 있다. 상품이 생성/수정될 때, 이 원본 데이터를 기반으로 검색에 필요한 데이터만 가공하여 Elasticsearch에 **인덱싱(Indexing)**하는 파이프라인을 구축했다.
- **3. 네이티브 기능 활용의 어려움과 해결:**
    - **핵심 경험:** JPA 환경에서 `JSONB`나 `Full-text search` 같은 **데이터베이스 고유의 기능**을 사용하려 할 때, JPA의 자동 번역 기능의 한계(`Unknown Types value`, `column name not found`)에 부딪혔다.
    - **해결 과정:** **`nativeQuery=true`*와 **SQL 별칭(Alias)** 또는 **`@SqlResultSetMapping`*을 사용하여, DB 컬럼명과 엔티티 필드명을 명시적으로 매핑해주는 것이 가장 확실한 해결책임을 배웠다.

### **Phase 3: 개인화 기반 마련 (추천 시스템)**

**목표:** 사용자 행동 데이터를 수집하고, 이를 가공하여 새로운 가치를 창출하는 경험을 한다.

- **1. 데이터 수집의 중요성:**
    - **키포인트:** 모든 개인화와 추천의 시작은 **'로그(Log) 수집'**이다. `product_view_logs` 테이블을 만들어 사용자의 모든 상품 조회 기록이라는 원재료를 쌓기 시작했다.
- **2. SQL을 이용한 데이터 분석:**
    - **핵심 경험:** 복잡한 머신러닝 없이도, 순수한 **SQL(JOIN, GROUP BY, COUNT, ORDER BY)**만으로도 "함께 본 상품"과 같은 의미 있는 비즈니스 인사이트를 추출하고, 이를 추천 기능으로 구현할 수 있다는 것을 배웠다.
- **3. 사용자 경험으로의 연결:**
    - **키포인트:** 백엔드에서 가공된 데이터를 API로 제공하고, 프론트엔드에서는 이를 받아 사용자에게 **'가치 있는 제안'**의 형태로 보여주었다. 이것이 바로 데이터 기반 서비스의 가장 기본적인 사이클이다.

### **Phase 4: 세상에 내놓기 (AWS 배포 및 CI/CD)**

**목표:** 내 컴퓨터를 벗어나, 실제 클라우드 환경에 서비스를 배포하고 운영하는 경험을 한다.

- **1. 클라우드 인프라 구축 (IaaS):**
    - **키포인트:** **EC2(서버), RDS(데이터베이스), S3(스토리지)** 등 각기 다른 역할을 하는 AWS 서비스들을 조합하여 애플리케이션이 동작할 수 있는 인프라를 직접 구축했다.
    - **핵심 경험:** **보안 그룹(Security Group)**은 클라우드의 핵심적인 '방화벽'이다. **EC2와 RDS가 서로 통신**하려면, RDS의 보안 그룹 인바운드 규칙에 EC2의 보안 그룹을 소스로 등록해주어야 한다는 네트워크의 기본 원리를 체득했다.
- **2. 개발 환경과 운영 환경의 차이:**
    - **핵심 경험:** `.jar` 파일에는 코드만 포함될 뿐, `.env` 같은 **환경 의존적인 설정 파일은 포함되지 않는다.** 따라서 실제 서버 환경에 맞는 `.env` 파일을 직접 서버에 생성하고, 애플리케이션 실행 시 `D` 옵션 등으로 해당 설정을 읽도록 지정해주어야 한다는 배포의 핵심 원리를 배웠다.
- **3. CI/CD 자동화 (GitHub Actions):**
    - **키포인트:** **빌드-테스트-배포**로 이어지는 반복적인 작업을 자동화했다. `main` 브랜치에 코드를 `push`하는 것만으로 모든 배포가 완료되는 파이프라인을 구축했다.
    - **핵심 경험:** GitHub 레포지토리의 **Secrets** 기능을 사용하여, AWS 액세스 키와 같은 민감한 정보를 코드에 노출하지 않고 안전하게 자동화 스크립트에서 사용하는 방법을 익혔다.
